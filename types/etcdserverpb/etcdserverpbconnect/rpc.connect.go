// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: etcdserverpb/rpc.proto

package etcdserverpbconnect

import (
	connect "connectrpc.com/connect"
	context "context"
	errors "errors"
	etcdserverpb "go.withmatt.com/connect-etcd/types/etcdserverpb"
	http "net/http"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect.IsAtLeastVersion0_1_0

const (
	// KVName is the fully-qualified name of the KV service.
	KVName = "etcdserverpb.KV"
	// WatchName is the fully-qualified name of the Watch service.
	WatchName = "etcdserverpb.Watch"
	// LeaseName is the fully-qualified name of the Lease service.
	LeaseName = "etcdserverpb.Lease"
	// ClusterName is the fully-qualified name of the Cluster service.
	ClusterName = "etcdserverpb.Cluster"
	// MaintenanceName is the fully-qualified name of the Maintenance service.
	MaintenanceName = "etcdserverpb.Maintenance"
	// AuthName is the fully-qualified name of the Auth service.
	AuthName = "etcdserverpb.Auth"
)

// These constants are the fully-qualified names of the RPCs defined in this package. They're
// exposed at runtime as Spec.Procedure and as the final two segments of the HTTP route.
//
// Note that these are different from the fully-qualified method names used by
// google.golang.org/protobuf/reflect/protoreflect. To convert from these constants to
// reflection-formatted method names, remove the leading slash and convert the remaining slash to a
// period.
const (
	// KVRangeProcedure is the fully-qualified name of the KV's Range RPC.
	KVRangeProcedure = "/etcdserverpb.KV/Range"
	// KVPutProcedure is the fully-qualified name of the KV's Put RPC.
	KVPutProcedure = "/etcdserverpb.KV/Put"
	// KVDeleteRangeProcedure is the fully-qualified name of the KV's DeleteRange RPC.
	KVDeleteRangeProcedure = "/etcdserverpb.KV/DeleteRange"
	// KVTxnProcedure is the fully-qualified name of the KV's Txn RPC.
	KVTxnProcedure = "/etcdserverpb.KV/Txn"
	// KVCompactProcedure is the fully-qualified name of the KV's Compact RPC.
	KVCompactProcedure = "/etcdserverpb.KV/Compact"
	// WatchWatchProcedure is the fully-qualified name of the Watch's Watch RPC.
	WatchWatchProcedure = "/etcdserverpb.Watch/Watch"
	// LeaseLeaseGrantProcedure is the fully-qualified name of the Lease's LeaseGrant RPC.
	LeaseLeaseGrantProcedure = "/etcdserverpb.Lease/LeaseGrant"
	// LeaseLeaseRevokeProcedure is the fully-qualified name of the Lease's LeaseRevoke RPC.
	LeaseLeaseRevokeProcedure = "/etcdserverpb.Lease/LeaseRevoke"
	// LeaseLeaseKeepAliveProcedure is the fully-qualified name of the Lease's LeaseKeepAlive RPC.
	LeaseLeaseKeepAliveProcedure = "/etcdserverpb.Lease/LeaseKeepAlive"
	// LeaseLeaseTimeToLiveProcedure is the fully-qualified name of the Lease's LeaseTimeToLive RPC.
	LeaseLeaseTimeToLiveProcedure = "/etcdserverpb.Lease/LeaseTimeToLive"
	// LeaseLeaseLeasesProcedure is the fully-qualified name of the Lease's LeaseLeases RPC.
	LeaseLeaseLeasesProcedure = "/etcdserverpb.Lease/LeaseLeases"
	// ClusterMemberAddProcedure is the fully-qualified name of the Cluster's MemberAdd RPC.
	ClusterMemberAddProcedure = "/etcdserverpb.Cluster/MemberAdd"
	// ClusterMemberRemoveProcedure is the fully-qualified name of the Cluster's MemberRemove RPC.
	ClusterMemberRemoveProcedure = "/etcdserverpb.Cluster/MemberRemove"
	// ClusterMemberUpdateProcedure is the fully-qualified name of the Cluster's MemberUpdate RPC.
	ClusterMemberUpdateProcedure = "/etcdserverpb.Cluster/MemberUpdate"
	// ClusterMemberListProcedure is the fully-qualified name of the Cluster's MemberList RPC.
	ClusterMemberListProcedure = "/etcdserverpb.Cluster/MemberList"
	// ClusterMemberPromoteProcedure is the fully-qualified name of the Cluster's MemberPromote RPC.
	ClusterMemberPromoteProcedure = "/etcdserverpb.Cluster/MemberPromote"
	// MaintenanceAlarmProcedure is the fully-qualified name of the Maintenance's Alarm RPC.
	MaintenanceAlarmProcedure = "/etcdserverpb.Maintenance/Alarm"
	// MaintenanceStatusProcedure is the fully-qualified name of the Maintenance's Status RPC.
	MaintenanceStatusProcedure = "/etcdserverpb.Maintenance/Status"
	// MaintenanceDefragmentProcedure is the fully-qualified name of the Maintenance's Defragment RPC.
	MaintenanceDefragmentProcedure = "/etcdserverpb.Maintenance/Defragment"
	// MaintenanceHashProcedure is the fully-qualified name of the Maintenance's Hash RPC.
	MaintenanceHashProcedure = "/etcdserverpb.Maintenance/Hash"
	// MaintenanceHashKVProcedure is the fully-qualified name of the Maintenance's HashKV RPC.
	MaintenanceHashKVProcedure = "/etcdserverpb.Maintenance/HashKV"
	// MaintenanceSnapshotProcedure is the fully-qualified name of the Maintenance's Snapshot RPC.
	MaintenanceSnapshotProcedure = "/etcdserverpb.Maintenance/Snapshot"
	// MaintenanceMoveLeaderProcedure is the fully-qualified name of the Maintenance's MoveLeader RPC.
	MaintenanceMoveLeaderProcedure = "/etcdserverpb.Maintenance/MoveLeader"
	// MaintenanceDowngradeProcedure is the fully-qualified name of the Maintenance's Downgrade RPC.
	MaintenanceDowngradeProcedure = "/etcdserverpb.Maintenance/Downgrade"
	// AuthAuthEnableProcedure is the fully-qualified name of the Auth's AuthEnable RPC.
	AuthAuthEnableProcedure = "/etcdserverpb.Auth/AuthEnable"
	// AuthAuthDisableProcedure is the fully-qualified name of the Auth's AuthDisable RPC.
	AuthAuthDisableProcedure = "/etcdserverpb.Auth/AuthDisable"
	// AuthAuthStatusProcedure is the fully-qualified name of the Auth's AuthStatus RPC.
	AuthAuthStatusProcedure = "/etcdserverpb.Auth/AuthStatus"
	// AuthAuthenticateProcedure is the fully-qualified name of the Auth's Authenticate RPC.
	AuthAuthenticateProcedure = "/etcdserverpb.Auth/Authenticate"
	// AuthUserAddProcedure is the fully-qualified name of the Auth's UserAdd RPC.
	AuthUserAddProcedure = "/etcdserverpb.Auth/UserAdd"
	// AuthUserGetProcedure is the fully-qualified name of the Auth's UserGet RPC.
	AuthUserGetProcedure = "/etcdserverpb.Auth/UserGet"
	// AuthUserListProcedure is the fully-qualified name of the Auth's UserList RPC.
	AuthUserListProcedure = "/etcdserverpb.Auth/UserList"
	// AuthUserDeleteProcedure is the fully-qualified name of the Auth's UserDelete RPC.
	AuthUserDeleteProcedure = "/etcdserverpb.Auth/UserDelete"
	// AuthUserChangePasswordProcedure is the fully-qualified name of the Auth's UserChangePassword RPC.
	AuthUserChangePasswordProcedure = "/etcdserverpb.Auth/UserChangePassword"
	// AuthUserGrantRoleProcedure is the fully-qualified name of the Auth's UserGrantRole RPC.
	AuthUserGrantRoleProcedure = "/etcdserverpb.Auth/UserGrantRole"
	// AuthUserRevokeRoleProcedure is the fully-qualified name of the Auth's UserRevokeRole RPC.
	AuthUserRevokeRoleProcedure = "/etcdserverpb.Auth/UserRevokeRole"
	// AuthRoleAddProcedure is the fully-qualified name of the Auth's RoleAdd RPC.
	AuthRoleAddProcedure = "/etcdserverpb.Auth/RoleAdd"
	// AuthRoleGetProcedure is the fully-qualified name of the Auth's RoleGet RPC.
	AuthRoleGetProcedure = "/etcdserverpb.Auth/RoleGet"
	// AuthRoleListProcedure is the fully-qualified name of the Auth's RoleList RPC.
	AuthRoleListProcedure = "/etcdserverpb.Auth/RoleList"
	// AuthRoleDeleteProcedure is the fully-qualified name of the Auth's RoleDelete RPC.
	AuthRoleDeleteProcedure = "/etcdserverpb.Auth/RoleDelete"
	// AuthRoleGrantPermissionProcedure is the fully-qualified name of the Auth's RoleGrantPermission
	// RPC.
	AuthRoleGrantPermissionProcedure = "/etcdserverpb.Auth/RoleGrantPermission"
	// AuthRoleRevokePermissionProcedure is the fully-qualified name of the Auth's RoleRevokePermission
	// RPC.
	AuthRoleRevokePermissionProcedure = "/etcdserverpb.Auth/RoleRevokePermission"
)

// KVClient is a client for the etcdserverpb.KV service.
type KVClient interface {
	// Range gets the keys in the range from the key-value store.
	Range(context.Context, *connect.Request[etcdserverpb.RangeRequest]) (*connect.Response[etcdserverpb.RangeResponse], error)
	// Put puts the given key into the key-value store.
	// A put request increments the revision of the key-value store
	// and generates one event in the event history.
	Put(context.Context, *connect.Request[etcdserverpb.PutRequest]) (*connect.Response[etcdserverpb.PutResponse], error)
	// DeleteRange deletes the given range from the key-value store.
	// A delete request increments the revision of the key-value store
	// and generates a delete event in the event history for every deleted key.
	DeleteRange(context.Context, *connect.Request[etcdserverpb.DeleteRangeRequest]) (*connect.Response[etcdserverpb.DeleteRangeResponse], error)
	// Txn processes multiple requests in a single transaction.
	// A txn request increments the revision of the key-value store
	// and generates events with the same revision for every completed request.
	// It is not allowed to modify the same key several times within one txn.
	Txn(context.Context, *connect.Request[etcdserverpb.TxnRequest]) (*connect.Response[etcdserverpb.TxnResponse], error)
	// Compact compacts the event history in the etcd key-value store. The key-value
	// store should be periodically compacted or the event history will continue to grow
	// indefinitely.
	Compact(context.Context, *connect.Request[etcdserverpb.CompactionRequest]) (*connect.Response[etcdserverpb.CompactionResponse], error)
}

// NewKVClient constructs a client for the etcdserverpb.KV service. By default, it uses the Connect
// protocol with the binary Protobuf Codec, asks for gzipped responses, and sends uncompressed
// requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or
// connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewKVClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) KVClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &kVClient{
		_range: connect.NewClient[etcdserverpb.RangeRequest, etcdserverpb.RangeResponse](
			httpClient,
			baseURL+KVRangeProcedure,
			opts...,
		),
		put: connect.NewClient[etcdserverpb.PutRequest, etcdserverpb.PutResponse](
			httpClient,
			baseURL+KVPutProcedure,
			opts...,
		),
		deleteRange: connect.NewClient[etcdserverpb.DeleteRangeRequest, etcdserverpb.DeleteRangeResponse](
			httpClient,
			baseURL+KVDeleteRangeProcedure,
			opts...,
		),
		txn: connect.NewClient[etcdserverpb.TxnRequest, etcdserverpb.TxnResponse](
			httpClient,
			baseURL+KVTxnProcedure,
			opts...,
		),
		compact: connect.NewClient[etcdserverpb.CompactionRequest, etcdserverpb.CompactionResponse](
			httpClient,
			baseURL+KVCompactProcedure,
			opts...,
		),
	}
}

// kVClient implements KVClient.
type kVClient struct {
	_range      *connect.Client[etcdserverpb.RangeRequest, etcdserverpb.RangeResponse]
	put         *connect.Client[etcdserverpb.PutRequest, etcdserverpb.PutResponse]
	deleteRange *connect.Client[etcdserverpb.DeleteRangeRequest, etcdserverpb.DeleteRangeResponse]
	txn         *connect.Client[etcdserverpb.TxnRequest, etcdserverpb.TxnResponse]
	compact     *connect.Client[etcdserverpb.CompactionRequest, etcdserverpb.CompactionResponse]
}

// Range calls etcdserverpb.KV.Range.
func (c *kVClient) Range(ctx context.Context, req *connect.Request[etcdserverpb.RangeRequest]) (*connect.Response[etcdserverpb.RangeResponse], error) {
	return c._range.CallUnary(ctx, req)
}

// Put calls etcdserverpb.KV.Put.
func (c *kVClient) Put(ctx context.Context, req *connect.Request[etcdserverpb.PutRequest]) (*connect.Response[etcdserverpb.PutResponse], error) {
	return c.put.CallUnary(ctx, req)
}

// DeleteRange calls etcdserverpb.KV.DeleteRange.
func (c *kVClient) DeleteRange(ctx context.Context, req *connect.Request[etcdserverpb.DeleteRangeRequest]) (*connect.Response[etcdserverpb.DeleteRangeResponse], error) {
	return c.deleteRange.CallUnary(ctx, req)
}

// Txn calls etcdserverpb.KV.Txn.
func (c *kVClient) Txn(ctx context.Context, req *connect.Request[etcdserverpb.TxnRequest]) (*connect.Response[etcdserverpb.TxnResponse], error) {
	return c.txn.CallUnary(ctx, req)
}

// Compact calls etcdserverpb.KV.Compact.
func (c *kVClient) Compact(ctx context.Context, req *connect.Request[etcdserverpb.CompactionRequest]) (*connect.Response[etcdserverpb.CompactionResponse], error) {
	return c.compact.CallUnary(ctx, req)
}

// KVHandler is an implementation of the etcdserverpb.KV service.
type KVHandler interface {
	// Range gets the keys in the range from the key-value store.
	Range(context.Context, *connect.Request[etcdserverpb.RangeRequest]) (*connect.Response[etcdserverpb.RangeResponse], error)
	// Put puts the given key into the key-value store.
	// A put request increments the revision of the key-value store
	// and generates one event in the event history.
	Put(context.Context, *connect.Request[etcdserverpb.PutRequest]) (*connect.Response[etcdserverpb.PutResponse], error)
	// DeleteRange deletes the given range from the key-value store.
	// A delete request increments the revision of the key-value store
	// and generates a delete event in the event history for every deleted key.
	DeleteRange(context.Context, *connect.Request[etcdserverpb.DeleteRangeRequest]) (*connect.Response[etcdserverpb.DeleteRangeResponse], error)
	// Txn processes multiple requests in a single transaction.
	// A txn request increments the revision of the key-value store
	// and generates events with the same revision for every completed request.
	// It is not allowed to modify the same key several times within one txn.
	Txn(context.Context, *connect.Request[etcdserverpb.TxnRequest]) (*connect.Response[etcdserverpb.TxnResponse], error)
	// Compact compacts the event history in the etcd key-value store. The key-value
	// store should be periodically compacted or the event history will continue to grow
	// indefinitely.
	Compact(context.Context, *connect.Request[etcdserverpb.CompactionRequest]) (*connect.Response[etcdserverpb.CompactionResponse], error)
}

// NewKVHandler builds an HTTP handler from the service implementation. It returns the path on which
// to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewKVHandler(svc KVHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	kVRangeHandler := connect.NewUnaryHandler(
		KVRangeProcedure,
		svc.Range,
		opts...,
	)
	kVPutHandler := connect.NewUnaryHandler(
		KVPutProcedure,
		svc.Put,
		opts...,
	)
	kVDeleteRangeHandler := connect.NewUnaryHandler(
		KVDeleteRangeProcedure,
		svc.DeleteRange,
		opts...,
	)
	kVTxnHandler := connect.NewUnaryHandler(
		KVTxnProcedure,
		svc.Txn,
		opts...,
	)
	kVCompactHandler := connect.NewUnaryHandler(
		KVCompactProcedure,
		svc.Compact,
		opts...,
	)
	return "/etcdserverpb.KV/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case KVRangeProcedure:
			kVRangeHandler.ServeHTTP(w, r)
		case KVPutProcedure:
			kVPutHandler.ServeHTTP(w, r)
		case KVDeleteRangeProcedure:
			kVDeleteRangeHandler.ServeHTTP(w, r)
		case KVTxnProcedure:
			kVTxnHandler.ServeHTTP(w, r)
		case KVCompactProcedure:
			kVCompactHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedKVHandler returns CodeUnimplemented from all methods.
type UnimplementedKVHandler struct{}

func (UnimplementedKVHandler) Range(context.Context, *connect.Request[etcdserverpb.RangeRequest]) (*connect.Response[etcdserverpb.RangeResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("etcdserverpb.KV.Range is not implemented"))
}

func (UnimplementedKVHandler) Put(context.Context, *connect.Request[etcdserverpb.PutRequest]) (*connect.Response[etcdserverpb.PutResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("etcdserverpb.KV.Put is not implemented"))
}

func (UnimplementedKVHandler) DeleteRange(context.Context, *connect.Request[etcdserverpb.DeleteRangeRequest]) (*connect.Response[etcdserverpb.DeleteRangeResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("etcdserverpb.KV.DeleteRange is not implemented"))
}

func (UnimplementedKVHandler) Txn(context.Context, *connect.Request[etcdserverpb.TxnRequest]) (*connect.Response[etcdserverpb.TxnResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("etcdserverpb.KV.Txn is not implemented"))
}

func (UnimplementedKVHandler) Compact(context.Context, *connect.Request[etcdserverpb.CompactionRequest]) (*connect.Response[etcdserverpb.CompactionResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("etcdserverpb.KV.Compact is not implemented"))
}

// WatchClient is a client for the etcdserverpb.Watch service.
type WatchClient interface {
	// Watch watches for events happening or that have happened. Both input and output
	// are streams; the input stream is for creating and canceling watchers and the output
	// stream sends events. One watch RPC can watch on multiple key ranges, streaming events
	// for several watches at once. The entire event history can be watched starting from the
	// last compaction revision.
	Watch(context.Context) *connect.BidiStreamForClient[etcdserverpb.WatchRequest, etcdserverpb.WatchResponse]
}

// NewWatchClient constructs a client for the etcdserverpb.Watch service. By default, it uses the
// Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and sends
// uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or
// connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewWatchClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) WatchClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &watchClient{
		watch: connect.NewClient[etcdserverpb.WatchRequest, etcdserverpb.WatchResponse](
			httpClient,
			baseURL+WatchWatchProcedure,
			opts...,
		),
	}
}

// watchClient implements WatchClient.
type watchClient struct {
	watch *connect.Client[etcdserverpb.WatchRequest, etcdserverpb.WatchResponse]
}

// Watch calls etcdserverpb.Watch.Watch.
func (c *watchClient) Watch(ctx context.Context) *connect.BidiStreamForClient[etcdserverpb.WatchRequest, etcdserverpb.WatchResponse] {
	return c.watch.CallBidiStream(ctx)
}

// WatchHandler is an implementation of the etcdserverpb.Watch service.
type WatchHandler interface {
	// Watch watches for events happening or that have happened. Both input and output
	// are streams; the input stream is for creating and canceling watchers and the output
	// stream sends events. One watch RPC can watch on multiple key ranges, streaming events
	// for several watches at once. The entire event history can be watched starting from the
	// last compaction revision.
	Watch(context.Context, *connect.BidiStream[etcdserverpb.WatchRequest, etcdserverpb.WatchResponse]) error
}

// NewWatchHandler builds an HTTP handler from the service implementation. It returns the path on
// which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewWatchHandler(svc WatchHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	watchWatchHandler := connect.NewBidiStreamHandler(
		WatchWatchProcedure,
		svc.Watch,
		opts...,
	)
	return "/etcdserverpb.Watch/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case WatchWatchProcedure:
			watchWatchHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedWatchHandler returns CodeUnimplemented from all methods.
type UnimplementedWatchHandler struct{}

func (UnimplementedWatchHandler) Watch(context.Context, *connect.BidiStream[etcdserverpb.WatchRequest, etcdserverpb.WatchResponse]) error {
	return connect.NewError(connect.CodeUnimplemented, errors.New("etcdserverpb.Watch.Watch is not implemented"))
}

// LeaseClient is a client for the etcdserverpb.Lease service.
type LeaseClient interface {
	// LeaseGrant creates a lease which expires if the server does not receive a keepAlive
	// within a given time to live period. All keys attached to the lease will be expired and
	// deleted if the lease expires. Each expired key generates a delete event in the event history.
	LeaseGrant(context.Context, *connect.Request[etcdserverpb.LeaseGrantRequest]) (*connect.Response[etcdserverpb.LeaseGrantResponse], error)
	// LeaseRevoke revokes a lease. All keys attached to the lease will expire and be deleted.
	LeaseRevoke(context.Context, *connect.Request[etcdserverpb.LeaseRevokeRequest]) (*connect.Response[etcdserverpb.LeaseRevokeResponse], error)
	// LeaseKeepAlive keeps the lease alive by streaming keep alive requests from the client
	// to the server and streaming keep alive responses from the server to the client.
	LeaseKeepAlive(context.Context) *connect.BidiStreamForClient[etcdserverpb.LeaseKeepAliveRequest, etcdserverpb.LeaseKeepAliveResponse]
	// LeaseTimeToLive retrieves lease information.
	LeaseTimeToLive(context.Context, *connect.Request[etcdserverpb.LeaseTimeToLiveRequest]) (*connect.Response[etcdserverpb.LeaseTimeToLiveResponse], error)
	// LeaseLeases lists all existing leases.
	LeaseLeases(context.Context, *connect.Request[etcdserverpb.LeaseLeasesRequest]) (*connect.Response[etcdserverpb.LeaseLeasesResponse], error)
}

// NewLeaseClient constructs a client for the etcdserverpb.Lease service. By default, it uses the
// Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and sends
// uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or
// connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewLeaseClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) LeaseClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &leaseClient{
		leaseGrant: connect.NewClient[etcdserverpb.LeaseGrantRequest, etcdserverpb.LeaseGrantResponse](
			httpClient,
			baseURL+LeaseLeaseGrantProcedure,
			opts...,
		),
		leaseRevoke: connect.NewClient[etcdserverpb.LeaseRevokeRequest, etcdserverpb.LeaseRevokeResponse](
			httpClient,
			baseURL+LeaseLeaseRevokeProcedure,
			opts...,
		),
		leaseKeepAlive: connect.NewClient[etcdserverpb.LeaseKeepAliveRequest, etcdserverpb.LeaseKeepAliveResponse](
			httpClient,
			baseURL+LeaseLeaseKeepAliveProcedure,
			opts...,
		),
		leaseTimeToLive: connect.NewClient[etcdserverpb.LeaseTimeToLiveRequest, etcdserverpb.LeaseTimeToLiveResponse](
			httpClient,
			baseURL+LeaseLeaseTimeToLiveProcedure,
			opts...,
		),
		leaseLeases: connect.NewClient[etcdserverpb.LeaseLeasesRequest, etcdserverpb.LeaseLeasesResponse](
			httpClient,
			baseURL+LeaseLeaseLeasesProcedure,
			opts...,
		),
	}
}

// leaseClient implements LeaseClient.
type leaseClient struct {
	leaseGrant      *connect.Client[etcdserverpb.LeaseGrantRequest, etcdserverpb.LeaseGrantResponse]
	leaseRevoke     *connect.Client[etcdserverpb.LeaseRevokeRequest, etcdserverpb.LeaseRevokeResponse]
	leaseKeepAlive  *connect.Client[etcdserverpb.LeaseKeepAliveRequest, etcdserverpb.LeaseKeepAliveResponse]
	leaseTimeToLive *connect.Client[etcdserverpb.LeaseTimeToLiveRequest, etcdserverpb.LeaseTimeToLiveResponse]
	leaseLeases     *connect.Client[etcdserverpb.LeaseLeasesRequest, etcdserverpb.LeaseLeasesResponse]
}

// LeaseGrant calls etcdserverpb.Lease.LeaseGrant.
func (c *leaseClient) LeaseGrant(ctx context.Context, req *connect.Request[etcdserverpb.LeaseGrantRequest]) (*connect.Response[etcdserverpb.LeaseGrantResponse], error) {
	return c.leaseGrant.CallUnary(ctx, req)
}

// LeaseRevoke calls etcdserverpb.Lease.LeaseRevoke.
func (c *leaseClient) LeaseRevoke(ctx context.Context, req *connect.Request[etcdserverpb.LeaseRevokeRequest]) (*connect.Response[etcdserverpb.LeaseRevokeResponse], error) {
	return c.leaseRevoke.CallUnary(ctx, req)
}

// LeaseKeepAlive calls etcdserverpb.Lease.LeaseKeepAlive.
func (c *leaseClient) LeaseKeepAlive(ctx context.Context) *connect.BidiStreamForClient[etcdserverpb.LeaseKeepAliveRequest, etcdserverpb.LeaseKeepAliveResponse] {
	return c.leaseKeepAlive.CallBidiStream(ctx)
}

// LeaseTimeToLive calls etcdserverpb.Lease.LeaseTimeToLive.
func (c *leaseClient) LeaseTimeToLive(ctx context.Context, req *connect.Request[etcdserverpb.LeaseTimeToLiveRequest]) (*connect.Response[etcdserverpb.LeaseTimeToLiveResponse], error) {
	return c.leaseTimeToLive.CallUnary(ctx, req)
}

// LeaseLeases calls etcdserverpb.Lease.LeaseLeases.
func (c *leaseClient) LeaseLeases(ctx context.Context, req *connect.Request[etcdserverpb.LeaseLeasesRequest]) (*connect.Response[etcdserverpb.LeaseLeasesResponse], error) {
	return c.leaseLeases.CallUnary(ctx, req)
}

// LeaseHandler is an implementation of the etcdserverpb.Lease service.
type LeaseHandler interface {
	// LeaseGrant creates a lease which expires if the server does not receive a keepAlive
	// within a given time to live period. All keys attached to the lease will be expired and
	// deleted if the lease expires. Each expired key generates a delete event in the event history.
	LeaseGrant(context.Context, *connect.Request[etcdserverpb.LeaseGrantRequest]) (*connect.Response[etcdserverpb.LeaseGrantResponse], error)
	// LeaseRevoke revokes a lease. All keys attached to the lease will expire and be deleted.
	LeaseRevoke(context.Context, *connect.Request[etcdserverpb.LeaseRevokeRequest]) (*connect.Response[etcdserverpb.LeaseRevokeResponse], error)
	// LeaseKeepAlive keeps the lease alive by streaming keep alive requests from the client
	// to the server and streaming keep alive responses from the server to the client.
	LeaseKeepAlive(context.Context, *connect.BidiStream[etcdserverpb.LeaseKeepAliveRequest, etcdserverpb.LeaseKeepAliveResponse]) error
	// LeaseTimeToLive retrieves lease information.
	LeaseTimeToLive(context.Context, *connect.Request[etcdserverpb.LeaseTimeToLiveRequest]) (*connect.Response[etcdserverpb.LeaseTimeToLiveResponse], error)
	// LeaseLeases lists all existing leases.
	LeaseLeases(context.Context, *connect.Request[etcdserverpb.LeaseLeasesRequest]) (*connect.Response[etcdserverpb.LeaseLeasesResponse], error)
}

// NewLeaseHandler builds an HTTP handler from the service implementation. It returns the path on
// which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewLeaseHandler(svc LeaseHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	leaseLeaseGrantHandler := connect.NewUnaryHandler(
		LeaseLeaseGrantProcedure,
		svc.LeaseGrant,
		opts...,
	)
	leaseLeaseRevokeHandler := connect.NewUnaryHandler(
		LeaseLeaseRevokeProcedure,
		svc.LeaseRevoke,
		opts...,
	)
	leaseLeaseKeepAliveHandler := connect.NewBidiStreamHandler(
		LeaseLeaseKeepAliveProcedure,
		svc.LeaseKeepAlive,
		opts...,
	)
	leaseLeaseTimeToLiveHandler := connect.NewUnaryHandler(
		LeaseLeaseTimeToLiveProcedure,
		svc.LeaseTimeToLive,
		opts...,
	)
	leaseLeaseLeasesHandler := connect.NewUnaryHandler(
		LeaseLeaseLeasesProcedure,
		svc.LeaseLeases,
		opts...,
	)
	return "/etcdserverpb.Lease/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case LeaseLeaseGrantProcedure:
			leaseLeaseGrantHandler.ServeHTTP(w, r)
		case LeaseLeaseRevokeProcedure:
			leaseLeaseRevokeHandler.ServeHTTP(w, r)
		case LeaseLeaseKeepAliveProcedure:
			leaseLeaseKeepAliveHandler.ServeHTTP(w, r)
		case LeaseLeaseTimeToLiveProcedure:
			leaseLeaseTimeToLiveHandler.ServeHTTP(w, r)
		case LeaseLeaseLeasesProcedure:
			leaseLeaseLeasesHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedLeaseHandler returns CodeUnimplemented from all methods.
type UnimplementedLeaseHandler struct{}

func (UnimplementedLeaseHandler) LeaseGrant(context.Context, *connect.Request[etcdserverpb.LeaseGrantRequest]) (*connect.Response[etcdserverpb.LeaseGrantResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("etcdserverpb.Lease.LeaseGrant is not implemented"))
}

func (UnimplementedLeaseHandler) LeaseRevoke(context.Context, *connect.Request[etcdserverpb.LeaseRevokeRequest]) (*connect.Response[etcdserverpb.LeaseRevokeResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("etcdserverpb.Lease.LeaseRevoke is not implemented"))
}

func (UnimplementedLeaseHandler) LeaseKeepAlive(context.Context, *connect.BidiStream[etcdserverpb.LeaseKeepAliveRequest, etcdserverpb.LeaseKeepAliveResponse]) error {
	return connect.NewError(connect.CodeUnimplemented, errors.New("etcdserverpb.Lease.LeaseKeepAlive is not implemented"))
}

func (UnimplementedLeaseHandler) LeaseTimeToLive(context.Context, *connect.Request[etcdserverpb.LeaseTimeToLiveRequest]) (*connect.Response[etcdserverpb.LeaseTimeToLiveResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("etcdserverpb.Lease.LeaseTimeToLive is not implemented"))
}

func (UnimplementedLeaseHandler) LeaseLeases(context.Context, *connect.Request[etcdserverpb.LeaseLeasesRequest]) (*connect.Response[etcdserverpb.LeaseLeasesResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("etcdserverpb.Lease.LeaseLeases is not implemented"))
}

// ClusterClient is a client for the etcdserverpb.Cluster service.
type ClusterClient interface {
	// MemberAdd adds a member into the cluster.
	MemberAdd(context.Context, *connect.Request[etcdserverpb.MemberAddRequest]) (*connect.Response[etcdserverpb.MemberAddResponse], error)
	// MemberRemove removes an existing member from the cluster.
	MemberRemove(context.Context, *connect.Request[etcdserverpb.MemberRemoveRequest]) (*connect.Response[etcdserverpb.MemberRemoveResponse], error)
	// MemberUpdate updates the member configuration.
	MemberUpdate(context.Context, *connect.Request[etcdserverpb.MemberUpdateRequest]) (*connect.Response[etcdserverpb.MemberUpdateResponse], error)
	// MemberList lists all the members in the cluster.
	MemberList(context.Context, *connect.Request[etcdserverpb.MemberListRequest]) (*connect.Response[etcdserverpb.MemberListResponse], error)
	// MemberPromote promotes a member from raft learner (non-voting) to raft voting member.
	MemberPromote(context.Context, *connect.Request[etcdserverpb.MemberPromoteRequest]) (*connect.Response[etcdserverpb.MemberPromoteResponse], error)
}

// NewClusterClient constructs a client for the etcdserverpb.Cluster service. By default, it uses
// the Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and sends
// uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or
// connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewClusterClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) ClusterClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &clusterClient{
		memberAdd: connect.NewClient[etcdserverpb.MemberAddRequest, etcdserverpb.MemberAddResponse](
			httpClient,
			baseURL+ClusterMemberAddProcedure,
			opts...,
		),
		memberRemove: connect.NewClient[etcdserverpb.MemberRemoveRequest, etcdserverpb.MemberRemoveResponse](
			httpClient,
			baseURL+ClusterMemberRemoveProcedure,
			opts...,
		),
		memberUpdate: connect.NewClient[etcdserverpb.MemberUpdateRequest, etcdserverpb.MemberUpdateResponse](
			httpClient,
			baseURL+ClusterMemberUpdateProcedure,
			opts...,
		),
		memberList: connect.NewClient[etcdserverpb.MemberListRequest, etcdserverpb.MemberListResponse](
			httpClient,
			baseURL+ClusterMemberListProcedure,
			opts...,
		),
		memberPromote: connect.NewClient[etcdserverpb.MemberPromoteRequest, etcdserverpb.MemberPromoteResponse](
			httpClient,
			baseURL+ClusterMemberPromoteProcedure,
			opts...,
		),
	}
}

// clusterClient implements ClusterClient.
type clusterClient struct {
	memberAdd     *connect.Client[etcdserverpb.MemberAddRequest, etcdserverpb.MemberAddResponse]
	memberRemove  *connect.Client[etcdserverpb.MemberRemoveRequest, etcdserverpb.MemberRemoveResponse]
	memberUpdate  *connect.Client[etcdserverpb.MemberUpdateRequest, etcdserverpb.MemberUpdateResponse]
	memberList    *connect.Client[etcdserverpb.MemberListRequest, etcdserverpb.MemberListResponse]
	memberPromote *connect.Client[etcdserverpb.MemberPromoteRequest, etcdserverpb.MemberPromoteResponse]
}

// MemberAdd calls etcdserverpb.Cluster.MemberAdd.
func (c *clusterClient) MemberAdd(ctx context.Context, req *connect.Request[etcdserverpb.MemberAddRequest]) (*connect.Response[etcdserverpb.MemberAddResponse], error) {
	return c.memberAdd.CallUnary(ctx, req)
}

// MemberRemove calls etcdserverpb.Cluster.MemberRemove.
func (c *clusterClient) MemberRemove(ctx context.Context, req *connect.Request[etcdserverpb.MemberRemoveRequest]) (*connect.Response[etcdserverpb.MemberRemoveResponse], error) {
	return c.memberRemove.CallUnary(ctx, req)
}

// MemberUpdate calls etcdserverpb.Cluster.MemberUpdate.
func (c *clusterClient) MemberUpdate(ctx context.Context, req *connect.Request[etcdserverpb.MemberUpdateRequest]) (*connect.Response[etcdserverpb.MemberUpdateResponse], error) {
	return c.memberUpdate.CallUnary(ctx, req)
}

// MemberList calls etcdserverpb.Cluster.MemberList.
func (c *clusterClient) MemberList(ctx context.Context, req *connect.Request[etcdserverpb.MemberListRequest]) (*connect.Response[etcdserverpb.MemberListResponse], error) {
	return c.memberList.CallUnary(ctx, req)
}

// MemberPromote calls etcdserverpb.Cluster.MemberPromote.
func (c *clusterClient) MemberPromote(ctx context.Context, req *connect.Request[etcdserverpb.MemberPromoteRequest]) (*connect.Response[etcdserverpb.MemberPromoteResponse], error) {
	return c.memberPromote.CallUnary(ctx, req)
}

// ClusterHandler is an implementation of the etcdserverpb.Cluster service.
type ClusterHandler interface {
	// MemberAdd adds a member into the cluster.
	MemberAdd(context.Context, *connect.Request[etcdserverpb.MemberAddRequest]) (*connect.Response[etcdserverpb.MemberAddResponse], error)
	// MemberRemove removes an existing member from the cluster.
	MemberRemove(context.Context, *connect.Request[etcdserverpb.MemberRemoveRequest]) (*connect.Response[etcdserverpb.MemberRemoveResponse], error)
	// MemberUpdate updates the member configuration.
	MemberUpdate(context.Context, *connect.Request[etcdserverpb.MemberUpdateRequest]) (*connect.Response[etcdserverpb.MemberUpdateResponse], error)
	// MemberList lists all the members in the cluster.
	MemberList(context.Context, *connect.Request[etcdserverpb.MemberListRequest]) (*connect.Response[etcdserverpb.MemberListResponse], error)
	// MemberPromote promotes a member from raft learner (non-voting) to raft voting member.
	MemberPromote(context.Context, *connect.Request[etcdserverpb.MemberPromoteRequest]) (*connect.Response[etcdserverpb.MemberPromoteResponse], error)
}

// NewClusterHandler builds an HTTP handler from the service implementation. It returns the path on
// which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewClusterHandler(svc ClusterHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	clusterMemberAddHandler := connect.NewUnaryHandler(
		ClusterMemberAddProcedure,
		svc.MemberAdd,
		opts...,
	)
	clusterMemberRemoveHandler := connect.NewUnaryHandler(
		ClusterMemberRemoveProcedure,
		svc.MemberRemove,
		opts...,
	)
	clusterMemberUpdateHandler := connect.NewUnaryHandler(
		ClusterMemberUpdateProcedure,
		svc.MemberUpdate,
		opts...,
	)
	clusterMemberListHandler := connect.NewUnaryHandler(
		ClusterMemberListProcedure,
		svc.MemberList,
		opts...,
	)
	clusterMemberPromoteHandler := connect.NewUnaryHandler(
		ClusterMemberPromoteProcedure,
		svc.MemberPromote,
		opts...,
	)
	return "/etcdserverpb.Cluster/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case ClusterMemberAddProcedure:
			clusterMemberAddHandler.ServeHTTP(w, r)
		case ClusterMemberRemoveProcedure:
			clusterMemberRemoveHandler.ServeHTTP(w, r)
		case ClusterMemberUpdateProcedure:
			clusterMemberUpdateHandler.ServeHTTP(w, r)
		case ClusterMemberListProcedure:
			clusterMemberListHandler.ServeHTTP(w, r)
		case ClusterMemberPromoteProcedure:
			clusterMemberPromoteHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedClusterHandler returns CodeUnimplemented from all methods.
type UnimplementedClusterHandler struct{}

func (UnimplementedClusterHandler) MemberAdd(context.Context, *connect.Request[etcdserverpb.MemberAddRequest]) (*connect.Response[etcdserverpb.MemberAddResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("etcdserverpb.Cluster.MemberAdd is not implemented"))
}

func (UnimplementedClusterHandler) MemberRemove(context.Context, *connect.Request[etcdserverpb.MemberRemoveRequest]) (*connect.Response[etcdserverpb.MemberRemoveResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("etcdserverpb.Cluster.MemberRemove is not implemented"))
}

func (UnimplementedClusterHandler) MemberUpdate(context.Context, *connect.Request[etcdserverpb.MemberUpdateRequest]) (*connect.Response[etcdserverpb.MemberUpdateResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("etcdserverpb.Cluster.MemberUpdate is not implemented"))
}

func (UnimplementedClusterHandler) MemberList(context.Context, *connect.Request[etcdserverpb.MemberListRequest]) (*connect.Response[etcdserverpb.MemberListResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("etcdserverpb.Cluster.MemberList is not implemented"))
}

func (UnimplementedClusterHandler) MemberPromote(context.Context, *connect.Request[etcdserverpb.MemberPromoteRequest]) (*connect.Response[etcdserverpb.MemberPromoteResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("etcdserverpb.Cluster.MemberPromote is not implemented"))
}

// MaintenanceClient is a client for the etcdserverpb.Maintenance service.
type MaintenanceClient interface {
	// Alarm activates, deactivates, and queries alarms regarding cluster health.
	Alarm(context.Context, *connect.Request[etcdserverpb.AlarmRequest]) (*connect.Response[etcdserverpb.AlarmResponse], error)
	// Status gets the status of the member.
	Status(context.Context, *connect.Request[etcdserverpb.StatusRequest]) (*connect.Response[etcdserverpb.StatusResponse], error)
	// Defragment defragments a member's backend database to recover storage space.
	Defragment(context.Context, *connect.Request[etcdserverpb.DefragmentRequest]) (*connect.Response[etcdserverpb.DefragmentResponse], error)
	// Hash computes the hash of whole backend keyspace,
	// including key, lease, and other buckets in storage.
	// This is designed for testing ONLY!
	// Do not rely on this in production with ongoing transactions,
	// since Hash operation does not hold MVCC locks.
	// Use "HashKV" API instead for "key" bucket consistency checks.
	Hash(context.Context, *connect.Request[etcdserverpb.HashRequest]) (*connect.Response[etcdserverpb.HashResponse], error)
	// HashKV computes the hash of all MVCC keys up to a given revision.
	// It only iterates "key" bucket in backend storage.
	HashKV(context.Context, *connect.Request[etcdserverpb.HashKVRequest]) (*connect.Response[etcdserverpb.HashKVResponse], error)
	// Snapshot sends a snapshot of the entire backend from a member over a stream to a client.
	Snapshot(context.Context, *connect.Request[etcdserverpb.SnapshotRequest]) (*connect.ServerStreamForClient[etcdserverpb.SnapshotResponse], error)
	// MoveLeader requests current leader node to transfer its leadership to transferee.
	MoveLeader(context.Context, *connect.Request[etcdserverpb.MoveLeaderRequest]) (*connect.Response[etcdserverpb.MoveLeaderResponse], error)
	// Downgrade requests downgrades, verifies feasibility or cancels downgrade
	// on the cluster version.
	// Supported since etcd 3.5.
	Downgrade(context.Context, *connect.Request[etcdserverpb.DowngradeRequest]) (*connect.Response[etcdserverpb.DowngradeResponse], error)
}

// NewMaintenanceClient constructs a client for the etcdserverpb.Maintenance service. By default, it
// uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and sends
// uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or
// connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewMaintenanceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) MaintenanceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &maintenanceClient{
		alarm: connect.NewClient[etcdserverpb.AlarmRequest, etcdserverpb.AlarmResponse](
			httpClient,
			baseURL+MaintenanceAlarmProcedure,
			opts...,
		),
		status: connect.NewClient[etcdserverpb.StatusRequest, etcdserverpb.StatusResponse](
			httpClient,
			baseURL+MaintenanceStatusProcedure,
			opts...,
		),
		defragment: connect.NewClient[etcdserverpb.DefragmentRequest, etcdserverpb.DefragmentResponse](
			httpClient,
			baseURL+MaintenanceDefragmentProcedure,
			opts...,
		),
		hash: connect.NewClient[etcdserverpb.HashRequest, etcdserverpb.HashResponse](
			httpClient,
			baseURL+MaintenanceHashProcedure,
			opts...,
		),
		hashKV: connect.NewClient[etcdserverpb.HashKVRequest, etcdserverpb.HashKVResponse](
			httpClient,
			baseURL+MaintenanceHashKVProcedure,
			opts...,
		),
		snapshot: connect.NewClient[etcdserverpb.SnapshotRequest, etcdserverpb.SnapshotResponse](
			httpClient,
			baseURL+MaintenanceSnapshotProcedure,
			opts...,
		),
		moveLeader: connect.NewClient[etcdserverpb.MoveLeaderRequest, etcdserverpb.MoveLeaderResponse](
			httpClient,
			baseURL+MaintenanceMoveLeaderProcedure,
			opts...,
		),
		downgrade: connect.NewClient[etcdserverpb.DowngradeRequest, etcdserverpb.DowngradeResponse](
			httpClient,
			baseURL+MaintenanceDowngradeProcedure,
			opts...,
		),
	}
}

// maintenanceClient implements MaintenanceClient.
type maintenanceClient struct {
	alarm      *connect.Client[etcdserverpb.AlarmRequest, etcdserverpb.AlarmResponse]
	status     *connect.Client[etcdserverpb.StatusRequest, etcdserverpb.StatusResponse]
	defragment *connect.Client[etcdserverpb.DefragmentRequest, etcdserverpb.DefragmentResponse]
	hash       *connect.Client[etcdserverpb.HashRequest, etcdserverpb.HashResponse]
	hashKV     *connect.Client[etcdserverpb.HashKVRequest, etcdserverpb.HashKVResponse]
	snapshot   *connect.Client[etcdserverpb.SnapshotRequest, etcdserverpb.SnapshotResponse]
	moveLeader *connect.Client[etcdserverpb.MoveLeaderRequest, etcdserverpb.MoveLeaderResponse]
	downgrade  *connect.Client[etcdserverpb.DowngradeRequest, etcdserverpb.DowngradeResponse]
}

// Alarm calls etcdserverpb.Maintenance.Alarm.
func (c *maintenanceClient) Alarm(ctx context.Context, req *connect.Request[etcdserverpb.AlarmRequest]) (*connect.Response[etcdserverpb.AlarmResponse], error) {
	return c.alarm.CallUnary(ctx, req)
}

// Status calls etcdserverpb.Maintenance.Status.
func (c *maintenanceClient) Status(ctx context.Context, req *connect.Request[etcdserverpb.StatusRequest]) (*connect.Response[etcdserverpb.StatusResponse], error) {
	return c.status.CallUnary(ctx, req)
}

// Defragment calls etcdserverpb.Maintenance.Defragment.
func (c *maintenanceClient) Defragment(ctx context.Context, req *connect.Request[etcdserverpb.DefragmentRequest]) (*connect.Response[etcdserverpb.DefragmentResponse], error) {
	return c.defragment.CallUnary(ctx, req)
}

// Hash calls etcdserverpb.Maintenance.Hash.
func (c *maintenanceClient) Hash(ctx context.Context, req *connect.Request[etcdserverpb.HashRequest]) (*connect.Response[etcdserverpb.HashResponse], error) {
	return c.hash.CallUnary(ctx, req)
}

// HashKV calls etcdserverpb.Maintenance.HashKV.
func (c *maintenanceClient) HashKV(ctx context.Context, req *connect.Request[etcdserverpb.HashKVRequest]) (*connect.Response[etcdserverpb.HashKVResponse], error) {
	return c.hashKV.CallUnary(ctx, req)
}

// Snapshot calls etcdserverpb.Maintenance.Snapshot.
func (c *maintenanceClient) Snapshot(ctx context.Context, req *connect.Request[etcdserverpb.SnapshotRequest]) (*connect.ServerStreamForClient[etcdserverpb.SnapshotResponse], error) {
	return c.snapshot.CallServerStream(ctx, req)
}

// MoveLeader calls etcdserverpb.Maintenance.MoveLeader.
func (c *maintenanceClient) MoveLeader(ctx context.Context, req *connect.Request[etcdserverpb.MoveLeaderRequest]) (*connect.Response[etcdserverpb.MoveLeaderResponse], error) {
	return c.moveLeader.CallUnary(ctx, req)
}

// Downgrade calls etcdserverpb.Maintenance.Downgrade.
func (c *maintenanceClient) Downgrade(ctx context.Context, req *connect.Request[etcdserverpb.DowngradeRequest]) (*connect.Response[etcdserverpb.DowngradeResponse], error) {
	return c.downgrade.CallUnary(ctx, req)
}

// MaintenanceHandler is an implementation of the etcdserverpb.Maintenance service.
type MaintenanceHandler interface {
	// Alarm activates, deactivates, and queries alarms regarding cluster health.
	Alarm(context.Context, *connect.Request[etcdserverpb.AlarmRequest]) (*connect.Response[etcdserverpb.AlarmResponse], error)
	// Status gets the status of the member.
	Status(context.Context, *connect.Request[etcdserverpb.StatusRequest]) (*connect.Response[etcdserverpb.StatusResponse], error)
	// Defragment defragments a member's backend database to recover storage space.
	Defragment(context.Context, *connect.Request[etcdserverpb.DefragmentRequest]) (*connect.Response[etcdserverpb.DefragmentResponse], error)
	// Hash computes the hash of whole backend keyspace,
	// including key, lease, and other buckets in storage.
	// This is designed for testing ONLY!
	// Do not rely on this in production with ongoing transactions,
	// since Hash operation does not hold MVCC locks.
	// Use "HashKV" API instead for "key" bucket consistency checks.
	Hash(context.Context, *connect.Request[etcdserverpb.HashRequest]) (*connect.Response[etcdserverpb.HashResponse], error)
	// HashKV computes the hash of all MVCC keys up to a given revision.
	// It only iterates "key" bucket in backend storage.
	HashKV(context.Context, *connect.Request[etcdserverpb.HashKVRequest]) (*connect.Response[etcdserverpb.HashKVResponse], error)
	// Snapshot sends a snapshot of the entire backend from a member over a stream to a client.
	Snapshot(context.Context, *connect.Request[etcdserverpb.SnapshotRequest], *connect.ServerStream[etcdserverpb.SnapshotResponse]) error
	// MoveLeader requests current leader node to transfer its leadership to transferee.
	MoveLeader(context.Context, *connect.Request[etcdserverpb.MoveLeaderRequest]) (*connect.Response[etcdserverpb.MoveLeaderResponse], error)
	// Downgrade requests downgrades, verifies feasibility or cancels downgrade
	// on the cluster version.
	// Supported since etcd 3.5.
	Downgrade(context.Context, *connect.Request[etcdserverpb.DowngradeRequest]) (*connect.Response[etcdserverpb.DowngradeResponse], error)
}

// NewMaintenanceHandler builds an HTTP handler from the service implementation. It returns the path
// on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewMaintenanceHandler(svc MaintenanceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	maintenanceAlarmHandler := connect.NewUnaryHandler(
		MaintenanceAlarmProcedure,
		svc.Alarm,
		opts...,
	)
	maintenanceStatusHandler := connect.NewUnaryHandler(
		MaintenanceStatusProcedure,
		svc.Status,
		opts...,
	)
	maintenanceDefragmentHandler := connect.NewUnaryHandler(
		MaintenanceDefragmentProcedure,
		svc.Defragment,
		opts...,
	)
	maintenanceHashHandler := connect.NewUnaryHandler(
		MaintenanceHashProcedure,
		svc.Hash,
		opts...,
	)
	maintenanceHashKVHandler := connect.NewUnaryHandler(
		MaintenanceHashKVProcedure,
		svc.HashKV,
		opts...,
	)
	maintenanceSnapshotHandler := connect.NewServerStreamHandler(
		MaintenanceSnapshotProcedure,
		svc.Snapshot,
		opts...,
	)
	maintenanceMoveLeaderHandler := connect.NewUnaryHandler(
		MaintenanceMoveLeaderProcedure,
		svc.MoveLeader,
		opts...,
	)
	maintenanceDowngradeHandler := connect.NewUnaryHandler(
		MaintenanceDowngradeProcedure,
		svc.Downgrade,
		opts...,
	)
	return "/etcdserverpb.Maintenance/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case MaintenanceAlarmProcedure:
			maintenanceAlarmHandler.ServeHTTP(w, r)
		case MaintenanceStatusProcedure:
			maintenanceStatusHandler.ServeHTTP(w, r)
		case MaintenanceDefragmentProcedure:
			maintenanceDefragmentHandler.ServeHTTP(w, r)
		case MaintenanceHashProcedure:
			maintenanceHashHandler.ServeHTTP(w, r)
		case MaintenanceHashKVProcedure:
			maintenanceHashKVHandler.ServeHTTP(w, r)
		case MaintenanceSnapshotProcedure:
			maintenanceSnapshotHandler.ServeHTTP(w, r)
		case MaintenanceMoveLeaderProcedure:
			maintenanceMoveLeaderHandler.ServeHTTP(w, r)
		case MaintenanceDowngradeProcedure:
			maintenanceDowngradeHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedMaintenanceHandler returns CodeUnimplemented from all methods.
type UnimplementedMaintenanceHandler struct{}

func (UnimplementedMaintenanceHandler) Alarm(context.Context, *connect.Request[etcdserverpb.AlarmRequest]) (*connect.Response[etcdserverpb.AlarmResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("etcdserverpb.Maintenance.Alarm is not implemented"))
}

func (UnimplementedMaintenanceHandler) Status(context.Context, *connect.Request[etcdserverpb.StatusRequest]) (*connect.Response[etcdserverpb.StatusResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("etcdserverpb.Maintenance.Status is not implemented"))
}

func (UnimplementedMaintenanceHandler) Defragment(context.Context, *connect.Request[etcdserverpb.DefragmentRequest]) (*connect.Response[etcdserverpb.DefragmentResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("etcdserverpb.Maintenance.Defragment is not implemented"))
}

func (UnimplementedMaintenanceHandler) Hash(context.Context, *connect.Request[etcdserverpb.HashRequest]) (*connect.Response[etcdserverpb.HashResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("etcdserverpb.Maintenance.Hash is not implemented"))
}

func (UnimplementedMaintenanceHandler) HashKV(context.Context, *connect.Request[etcdserverpb.HashKVRequest]) (*connect.Response[etcdserverpb.HashKVResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("etcdserverpb.Maintenance.HashKV is not implemented"))
}

func (UnimplementedMaintenanceHandler) Snapshot(context.Context, *connect.Request[etcdserverpb.SnapshotRequest], *connect.ServerStream[etcdserverpb.SnapshotResponse]) error {
	return connect.NewError(connect.CodeUnimplemented, errors.New("etcdserverpb.Maintenance.Snapshot is not implemented"))
}

func (UnimplementedMaintenanceHandler) MoveLeader(context.Context, *connect.Request[etcdserverpb.MoveLeaderRequest]) (*connect.Response[etcdserverpb.MoveLeaderResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("etcdserverpb.Maintenance.MoveLeader is not implemented"))
}

func (UnimplementedMaintenanceHandler) Downgrade(context.Context, *connect.Request[etcdserverpb.DowngradeRequest]) (*connect.Response[etcdserverpb.DowngradeResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("etcdserverpb.Maintenance.Downgrade is not implemented"))
}

// AuthClient is a client for the etcdserverpb.Auth service.
type AuthClient interface {
	// AuthEnable enables authentication.
	AuthEnable(context.Context, *connect.Request[etcdserverpb.AuthEnableRequest]) (*connect.Response[etcdserverpb.AuthEnableResponse], error)
	// AuthDisable disables authentication.
	AuthDisable(context.Context, *connect.Request[etcdserverpb.AuthDisableRequest]) (*connect.Response[etcdserverpb.AuthDisableResponse], error)
	// AuthStatus displays authentication status.
	AuthStatus(context.Context, *connect.Request[etcdserverpb.AuthStatusRequest]) (*connect.Response[etcdserverpb.AuthStatusResponse], error)
	// Authenticate processes an authenticate request.
	Authenticate(context.Context, *connect.Request[etcdserverpb.AuthenticateRequest]) (*connect.Response[etcdserverpb.AuthenticateResponse], error)
	// UserAdd adds a new user. User name cannot be empty.
	UserAdd(context.Context, *connect.Request[etcdserverpb.AuthUserAddRequest]) (*connect.Response[etcdserverpb.AuthUserAddResponse], error)
	// UserGet gets detailed user information.
	UserGet(context.Context, *connect.Request[etcdserverpb.AuthUserGetRequest]) (*connect.Response[etcdserverpb.AuthUserGetResponse], error)
	// UserList gets a list of all users.
	UserList(context.Context, *connect.Request[etcdserverpb.AuthUserListRequest]) (*connect.Response[etcdserverpb.AuthUserListResponse], error)
	// UserDelete deletes a specified user.
	UserDelete(context.Context, *connect.Request[etcdserverpb.AuthUserDeleteRequest]) (*connect.Response[etcdserverpb.AuthUserDeleteResponse], error)
	// UserChangePassword changes the password of a specified user.
	UserChangePassword(context.Context, *connect.Request[etcdserverpb.AuthUserChangePasswordRequest]) (*connect.Response[etcdserverpb.AuthUserChangePasswordResponse], error)
	// UserGrant grants a role to a specified user.
	UserGrantRole(context.Context, *connect.Request[etcdserverpb.AuthUserGrantRoleRequest]) (*connect.Response[etcdserverpb.AuthUserGrantRoleResponse], error)
	// UserRevokeRole revokes a role of specified user.
	UserRevokeRole(context.Context, *connect.Request[etcdserverpb.AuthUserRevokeRoleRequest]) (*connect.Response[etcdserverpb.AuthUserRevokeRoleResponse], error)
	// RoleAdd adds a new role. Role name cannot be empty.
	RoleAdd(context.Context, *connect.Request[etcdserverpb.AuthRoleAddRequest]) (*connect.Response[etcdserverpb.AuthRoleAddResponse], error)
	// RoleGet gets detailed role information.
	RoleGet(context.Context, *connect.Request[etcdserverpb.AuthRoleGetRequest]) (*connect.Response[etcdserverpb.AuthRoleGetResponse], error)
	// RoleList gets lists of all roles.
	RoleList(context.Context, *connect.Request[etcdserverpb.AuthRoleListRequest]) (*connect.Response[etcdserverpb.AuthRoleListResponse], error)
	// RoleDelete deletes a specified role.
	RoleDelete(context.Context, *connect.Request[etcdserverpb.AuthRoleDeleteRequest]) (*connect.Response[etcdserverpb.AuthRoleDeleteResponse], error)
	// RoleGrantPermission grants a permission of a specified key or range to a specified role.
	RoleGrantPermission(context.Context, *connect.Request[etcdserverpb.AuthRoleGrantPermissionRequest]) (*connect.Response[etcdserverpb.AuthRoleGrantPermissionResponse], error)
	// RoleRevokePermission revokes a key or range permission of a specified role.
	RoleRevokePermission(context.Context, *connect.Request[etcdserverpb.AuthRoleRevokePermissionRequest]) (*connect.Response[etcdserverpb.AuthRoleRevokePermissionResponse], error)
}

// NewAuthClient constructs a client for the etcdserverpb.Auth service. By default, it uses the
// Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and sends
// uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or
// connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewAuthClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) AuthClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &authClient{
		authEnable: connect.NewClient[etcdserverpb.AuthEnableRequest, etcdserverpb.AuthEnableResponse](
			httpClient,
			baseURL+AuthAuthEnableProcedure,
			opts...,
		),
		authDisable: connect.NewClient[etcdserverpb.AuthDisableRequest, etcdserverpb.AuthDisableResponse](
			httpClient,
			baseURL+AuthAuthDisableProcedure,
			opts...,
		),
		authStatus: connect.NewClient[etcdserverpb.AuthStatusRequest, etcdserverpb.AuthStatusResponse](
			httpClient,
			baseURL+AuthAuthStatusProcedure,
			opts...,
		),
		authenticate: connect.NewClient[etcdserverpb.AuthenticateRequest, etcdserverpb.AuthenticateResponse](
			httpClient,
			baseURL+AuthAuthenticateProcedure,
			opts...,
		),
		userAdd: connect.NewClient[etcdserverpb.AuthUserAddRequest, etcdserverpb.AuthUserAddResponse](
			httpClient,
			baseURL+AuthUserAddProcedure,
			opts...,
		),
		userGet: connect.NewClient[etcdserverpb.AuthUserGetRequest, etcdserverpb.AuthUserGetResponse](
			httpClient,
			baseURL+AuthUserGetProcedure,
			opts...,
		),
		userList: connect.NewClient[etcdserverpb.AuthUserListRequest, etcdserverpb.AuthUserListResponse](
			httpClient,
			baseURL+AuthUserListProcedure,
			opts...,
		),
		userDelete: connect.NewClient[etcdserverpb.AuthUserDeleteRequest, etcdserverpb.AuthUserDeleteResponse](
			httpClient,
			baseURL+AuthUserDeleteProcedure,
			opts...,
		),
		userChangePassword: connect.NewClient[etcdserverpb.AuthUserChangePasswordRequest, etcdserverpb.AuthUserChangePasswordResponse](
			httpClient,
			baseURL+AuthUserChangePasswordProcedure,
			opts...,
		),
		userGrantRole: connect.NewClient[etcdserverpb.AuthUserGrantRoleRequest, etcdserverpb.AuthUserGrantRoleResponse](
			httpClient,
			baseURL+AuthUserGrantRoleProcedure,
			opts...,
		),
		userRevokeRole: connect.NewClient[etcdserverpb.AuthUserRevokeRoleRequest, etcdserverpb.AuthUserRevokeRoleResponse](
			httpClient,
			baseURL+AuthUserRevokeRoleProcedure,
			opts...,
		),
		roleAdd: connect.NewClient[etcdserverpb.AuthRoleAddRequest, etcdserverpb.AuthRoleAddResponse](
			httpClient,
			baseURL+AuthRoleAddProcedure,
			opts...,
		),
		roleGet: connect.NewClient[etcdserverpb.AuthRoleGetRequest, etcdserverpb.AuthRoleGetResponse](
			httpClient,
			baseURL+AuthRoleGetProcedure,
			opts...,
		),
		roleList: connect.NewClient[etcdserverpb.AuthRoleListRequest, etcdserverpb.AuthRoleListResponse](
			httpClient,
			baseURL+AuthRoleListProcedure,
			opts...,
		),
		roleDelete: connect.NewClient[etcdserverpb.AuthRoleDeleteRequest, etcdserverpb.AuthRoleDeleteResponse](
			httpClient,
			baseURL+AuthRoleDeleteProcedure,
			opts...,
		),
		roleGrantPermission: connect.NewClient[etcdserverpb.AuthRoleGrantPermissionRequest, etcdserverpb.AuthRoleGrantPermissionResponse](
			httpClient,
			baseURL+AuthRoleGrantPermissionProcedure,
			opts...,
		),
		roleRevokePermission: connect.NewClient[etcdserverpb.AuthRoleRevokePermissionRequest, etcdserverpb.AuthRoleRevokePermissionResponse](
			httpClient,
			baseURL+AuthRoleRevokePermissionProcedure,
			opts...,
		),
	}
}

// authClient implements AuthClient.
type authClient struct {
	authEnable           *connect.Client[etcdserverpb.AuthEnableRequest, etcdserverpb.AuthEnableResponse]
	authDisable          *connect.Client[etcdserverpb.AuthDisableRequest, etcdserverpb.AuthDisableResponse]
	authStatus           *connect.Client[etcdserverpb.AuthStatusRequest, etcdserverpb.AuthStatusResponse]
	authenticate         *connect.Client[etcdserverpb.AuthenticateRequest, etcdserverpb.AuthenticateResponse]
	userAdd              *connect.Client[etcdserverpb.AuthUserAddRequest, etcdserverpb.AuthUserAddResponse]
	userGet              *connect.Client[etcdserverpb.AuthUserGetRequest, etcdserverpb.AuthUserGetResponse]
	userList             *connect.Client[etcdserverpb.AuthUserListRequest, etcdserverpb.AuthUserListResponse]
	userDelete           *connect.Client[etcdserverpb.AuthUserDeleteRequest, etcdserverpb.AuthUserDeleteResponse]
	userChangePassword   *connect.Client[etcdserverpb.AuthUserChangePasswordRequest, etcdserverpb.AuthUserChangePasswordResponse]
	userGrantRole        *connect.Client[etcdserverpb.AuthUserGrantRoleRequest, etcdserverpb.AuthUserGrantRoleResponse]
	userRevokeRole       *connect.Client[etcdserverpb.AuthUserRevokeRoleRequest, etcdserverpb.AuthUserRevokeRoleResponse]
	roleAdd              *connect.Client[etcdserverpb.AuthRoleAddRequest, etcdserverpb.AuthRoleAddResponse]
	roleGet              *connect.Client[etcdserverpb.AuthRoleGetRequest, etcdserverpb.AuthRoleGetResponse]
	roleList             *connect.Client[etcdserverpb.AuthRoleListRequest, etcdserverpb.AuthRoleListResponse]
	roleDelete           *connect.Client[etcdserverpb.AuthRoleDeleteRequest, etcdserverpb.AuthRoleDeleteResponse]
	roleGrantPermission  *connect.Client[etcdserverpb.AuthRoleGrantPermissionRequest, etcdserverpb.AuthRoleGrantPermissionResponse]
	roleRevokePermission *connect.Client[etcdserverpb.AuthRoleRevokePermissionRequest, etcdserverpb.AuthRoleRevokePermissionResponse]
}

// AuthEnable calls etcdserverpb.Auth.AuthEnable.
func (c *authClient) AuthEnable(ctx context.Context, req *connect.Request[etcdserverpb.AuthEnableRequest]) (*connect.Response[etcdserverpb.AuthEnableResponse], error) {
	return c.authEnable.CallUnary(ctx, req)
}

// AuthDisable calls etcdserverpb.Auth.AuthDisable.
func (c *authClient) AuthDisable(ctx context.Context, req *connect.Request[etcdserverpb.AuthDisableRequest]) (*connect.Response[etcdserverpb.AuthDisableResponse], error) {
	return c.authDisable.CallUnary(ctx, req)
}

// AuthStatus calls etcdserverpb.Auth.AuthStatus.
func (c *authClient) AuthStatus(ctx context.Context, req *connect.Request[etcdserverpb.AuthStatusRequest]) (*connect.Response[etcdserverpb.AuthStatusResponse], error) {
	return c.authStatus.CallUnary(ctx, req)
}

// Authenticate calls etcdserverpb.Auth.Authenticate.
func (c *authClient) Authenticate(ctx context.Context, req *connect.Request[etcdserverpb.AuthenticateRequest]) (*connect.Response[etcdserverpb.AuthenticateResponse], error) {
	return c.authenticate.CallUnary(ctx, req)
}

// UserAdd calls etcdserverpb.Auth.UserAdd.
func (c *authClient) UserAdd(ctx context.Context, req *connect.Request[etcdserverpb.AuthUserAddRequest]) (*connect.Response[etcdserverpb.AuthUserAddResponse], error) {
	return c.userAdd.CallUnary(ctx, req)
}

// UserGet calls etcdserverpb.Auth.UserGet.
func (c *authClient) UserGet(ctx context.Context, req *connect.Request[etcdserverpb.AuthUserGetRequest]) (*connect.Response[etcdserverpb.AuthUserGetResponse], error) {
	return c.userGet.CallUnary(ctx, req)
}

// UserList calls etcdserverpb.Auth.UserList.
func (c *authClient) UserList(ctx context.Context, req *connect.Request[etcdserverpb.AuthUserListRequest]) (*connect.Response[etcdserverpb.AuthUserListResponse], error) {
	return c.userList.CallUnary(ctx, req)
}

// UserDelete calls etcdserverpb.Auth.UserDelete.
func (c *authClient) UserDelete(ctx context.Context, req *connect.Request[etcdserverpb.AuthUserDeleteRequest]) (*connect.Response[etcdserverpb.AuthUserDeleteResponse], error) {
	return c.userDelete.CallUnary(ctx, req)
}

// UserChangePassword calls etcdserverpb.Auth.UserChangePassword.
func (c *authClient) UserChangePassword(ctx context.Context, req *connect.Request[etcdserverpb.AuthUserChangePasswordRequest]) (*connect.Response[etcdserverpb.AuthUserChangePasswordResponse], error) {
	return c.userChangePassword.CallUnary(ctx, req)
}

// UserGrantRole calls etcdserverpb.Auth.UserGrantRole.
func (c *authClient) UserGrantRole(ctx context.Context, req *connect.Request[etcdserverpb.AuthUserGrantRoleRequest]) (*connect.Response[etcdserverpb.AuthUserGrantRoleResponse], error) {
	return c.userGrantRole.CallUnary(ctx, req)
}

// UserRevokeRole calls etcdserverpb.Auth.UserRevokeRole.
func (c *authClient) UserRevokeRole(ctx context.Context, req *connect.Request[etcdserverpb.AuthUserRevokeRoleRequest]) (*connect.Response[etcdserverpb.AuthUserRevokeRoleResponse], error) {
	return c.userRevokeRole.CallUnary(ctx, req)
}

// RoleAdd calls etcdserverpb.Auth.RoleAdd.
func (c *authClient) RoleAdd(ctx context.Context, req *connect.Request[etcdserverpb.AuthRoleAddRequest]) (*connect.Response[etcdserverpb.AuthRoleAddResponse], error) {
	return c.roleAdd.CallUnary(ctx, req)
}

// RoleGet calls etcdserverpb.Auth.RoleGet.
func (c *authClient) RoleGet(ctx context.Context, req *connect.Request[etcdserverpb.AuthRoleGetRequest]) (*connect.Response[etcdserverpb.AuthRoleGetResponse], error) {
	return c.roleGet.CallUnary(ctx, req)
}

// RoleList calls etcdserverpb.Auth.RoleList.
func (c *authClient) RoleList(ctx context.Context, req *connect.Request[etcdserverpb.AuthRoleListRequest]) (*connect.Response[etcdserverpb.AuthRoleListResponse], error) {
	return c.roleList.CallUnary(ctx, req)
}

// RoleDelete calls etcdserverpb.Auth.RoleDelete.
func (c *authClient) RoleDelete(ctx context.Context, req *connect.Request[etcdserverpb.AuthRoleDeleteRequest]) (*connect.Response[etcdserverpb.AuthRoleDeleteResponse], error) {
	return c.roleDelete.CallUnary(ctx, req)
}

// RoleGrantPermission calls etcdserverpb.Auth.RoleGrantPermission.
func (c *authClient) RoleGrantPermission(ctx context.Context, req *connect.Request[etcdserverpb.AuthRoleGrantPermissionRequest]) (*connect.Response[etcdserverpb.AuthRoleGrantPermissionResponse], error) {
	return c.roleGrantPermission.CallUnary(ctx, req)
}

// RoleRevokePermission calls etcdserverpb.Auth.RoleRevokePermission.
func (c *authClient) RoleRevokePermission(ctx context.Context, req *connect.Request[etcdserverpb.AuthRoleRevokePermissionRequest]) (*connect.Response[etcdserverpb.AuthRoleRevokePermissionResponse], error) {
	return c.roleRevokePermission.CallUnary(ctx, req)
}

// AuthHandler is an implementation of the etcdserverpb.Auth service.
type AuthHandler interface {
	// AuthEnable enables authentication.
	AuthEnable(context.Context, *connect.Request[etcdserverpb.AuthEnableRequest]) (*connect.Response[etcdserverpb.AuthEnableResponse], error)
	// AuthDisable disables authentication.
	AuthDisable(context.Context, *connect.Request[etcdserverpb.AuthDisableRequest]) (*connect.Response[etcdserverpb.AuthDisableResponse], error)
	// AuthStatus displays authentication status.
	AuthStatus(context.Context, *connect.Request[etcdserverpb.AuthStatusRequest]) (*connect.Response[etcdserverpb.AuthStatusResponse], error)
	// Authenticate processes an authenticate request.
	Authenticate(context.Context, *connect.Request[etcdserverpb.AuthenticateRequest]) (*connect.Response[etcdserverpb.AuthenticateResponse], error)
	// UserAdd adds a new user. User name cannot be empty.
	UserAdd(context.Context, *connect.Request[etcdserverpb.AuthUserAddRequest]) (*connect.Response[etcdserverpb.AuthUserAddResponse], error)
	// UserGet gets detailed user information.
	UserGet(context.Context, *connect.Request[etcdserverpb.AuthUserGetRequest]) (*connect.Response[etcdserverpb.AuthUserGetResponse], error)
	// UserList gets a list of all users.
	UserList(context.Context, *connect.Request[etcdserverpb.AuthUserListRequest]) (*connect.Response[etcdserverpb.AuthUserListResponse], error)
	// UserDelete deletes a specified user.
	UserDelete(context.Context, *connect.Request[etcdserverpb.AuthUserDeleteRequest]) (*connect.Response[etcdserverpb.AuthUserDeleteResponse], error)
	// UserChangePassword changes the password of a specified user.
	UserChangePassword(context.Context, *connect.Request[etcdserverpb.AuthUserChangePasswordRequest]) (*connect.Response[etcdserverpb.AuthUserChangePasswordResponse], error)
	// UserGrant grants a role to a specified user.
	UserGrantRole(context.Context, *connect.Request[etcdserverpb.AuthUserGrantRoleRequest]) (*connect.Response[etcdserverpb.AuthUserGrantRoleResponse], error)
	// UserRevokeRole revokes a role of specified user.
	UserRevokeRole(context.Context, *connect.Request[etcdserverpb.AuthUserRevokeRoleRequest]) (*connect.Response[etcdserverpb.AuthUserRevokeRoleResponse], error)
	// RoleAdd adds a new role. Role name cannot be empty.
	RoleAdd(context.Context, *connect.Request[etcdserverpb.AuthRoleAddRequest]) (*connect.Response[etcdserverpb.AuthRoleAddResponse], error)
	// RoleGet gets detailed role information.
	RoleGet(context.Context, *connect.Request[etcdserverpb.AuthRoleGetRequest]) (*connect.Response[etcdserverpb.AuthRoleGetResponse], error)
	// RoleList gets lists of all roles.
	RoleList(context.Context, *connect.Request[etcdserverpb.AuthRoleListRequest]) (*connect.Response[etcdserverpb.AuthRoleListResponse], error)
	// RoleDelete deletes a specified role.
	RoleDelete(context.Context, *connect.Request[etcdserverpb.AuthRoleDeleteRequest]) (*connect.Response[etcdserverpb.AuthRoleDeleteResponse], error)
	// RoleGrantPermission grants a permission of a specified key or range to a specified role.
	RoleGrantPermission(context.Context, *connect.Request[etcdserverpb.AuthRoleGrantPermissionRequest]) (*connect.Response[etcdserverpb.AuthRoleGrantPermissionResponse], error)
	// RoleRevokePermission revokes a key or range permission of a specified role.
	RoleRevokePermission(context.Context, *connect.Request[etcdserverpb.AuthRoleRevokePermissionRequest]) (*connect.Response[etcdserverpb.AuthRoleRevokePermissionResponse], error)
}

// NewAuthHandler builds an HTTP handler from the service implementation. It returns the path on
// which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewAuthHandler(svc AuthHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	authAuthEnableHandler := connect.NewUnaryHandler(
		AuthAuthEnableProcedure,
		svc.AuthEnable,
		opts...,
	)
	authAuthDisableHandler := connect.NewUnaryHandler(
		AuthAuthDisableProcedure,
		svc.AuthDisable,
		opts...,
	)
	authAuthStatusHandler := connect.NewUnaryHandler(
		AuthAuthStatusProcedure,
		svc.AuthStatus,
		opts...,
	)
	authAuthenticateHandler := connect.NewUnaryHandler(
		AuthAuthenticateProcedure,
		svc.Authenticate,
		opts...,
	)
	authUserAddHandler := connect.NewUnaryHandler(
		AuthUserAddProcedure,
		svc.UserAdd,
		opts...,
	)
	authUserGetHandler := connect.NewUnaryHandler(
		AuthUserGetProcedure,
		svc.UserGet,
		opts...,
	)
	authUserListHandler := connect.NewUnaryHandler(
		AuthUserListProcedure,
		svc.UserList,
		opts...,
	)
	authUserDeleteHandler := connect.NewUnaryHandler(
		AuthUserDeleteProcedure,
		svc.UserDelete,
		opts...,
	)
	authUserChangePasswordHandler := connect.NewUnaryHandler(
		AuthUserChangePasswordProcedure,
		svc.UserChangePassword,
		opts...,
	)
	authUserGrantRoleHandler := connect.NewUnaryHandler(
		AuthUserGrantRoleProcedure,
		svc.UserGrantRole,
		opts...,
	)
	authUserRevokeRoleHandler := connect.NewUnaryHandler(
		AuthUserRevokeRoleProcedure,
		svc.UserRevokeRole,
		opts...,
	)
	authRoleAddHandler := connect.NewUnaryHandler(
		AuthRoleAddProcedure,
		svc.RoleAdd,
		opts...,
	)
	authRoleGetHandler := connect.NewUnaryHandler(
		AuthRoleGetProcedure,
		svc.RoleGet,
		opts...,
	)
	authRoleListHandler := connect.NewUnaryHandler(
		AuthRoleListProcedure,
		svc.RoleList,
		opts...,
	)
	authRoleDeleteHandler := connect.NewUnaryHandler(
		AuthRoleDeleteProcedure,
		svc.RoleDelete,
		opts...,
	)
	authRoleGrantPermissionHandler := connect.NewUnaryHandler(
		AuthRoleGrantPermissionProcedure,
		svc.RoleGrantPermission,
		opts...,
	)
	authRoleRevokePermissionHandler := connect.NewUnaryHandler(
		AuthRoleRevokePermissionProcedure,
		svc.RoleRevokePermission,
		opts...,
	)
	return "/etcdserverpb.Auth/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case AuthAuthEnableProcedure:
			authAuthEnableHandler.ServeHTTP(w, r)
		case AuthAuthDisableProcedure:
			authAuthDisableHandler.ServeHTTP(w, r)
		case AuthAuthStatusProcedure:
			authAuthStatusHandler.ServeHTTP(w, r)
		case AuthAuthenticateProcedure:
			authAuthenticateHandler.ServeHTTP(w, r)
		case AuthUserAddProcedure:
			authUserAddHandler.ServeHTTP(w, r)
		case AuthUserGetProcedure:
			authUserGetHandler.ServeHTTP(w, r)
		case AuthUserListProcedure:
			authUserListHandler.ServeHTTP(w, r)
		case AuthUserDeleteProcedure:
			authUserDeleteHandler.ServeHTTP(w, r)
		case AuthUserChangePasswordProcedure:
			authUserChangePasswordHandler.ServeHTTP(w, r)
		case AuthUserGrantRoleProcedure:
			authUserGrantRoleHandler.ServeHTTP(w, r)
		case AuthUserRevokeRoleProcedure:
			authUserRevokeRoleHandler.ServeHTTP(w, r)
		case AuthRoleAddProcedure:
			authRoleAddHandler.ServeHTTP(w, r)
		case AuthRoleGetProcedure:
			authRoleGetHandler.ServeHTTP(w, r)
		case AuthRoleListProcedure:
			authRoleListHandler.ServeHTTP(w, r)
		case AuthRoleDeleteProcedure:
			authRoleDeleteHandler.ServeHTTP(w, r)
		case AuthRoleGrantPermissionProcedure:
			authRoleGrantPermissionHandler.ServeHTTP(w, r)
		case AuthRoleRevokePermissionProcedure:
			authRoleRevokePermissionHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedAuthHandler returns CodeUnimplemented from all methods.
type UnimplementedAuthHandler struct{}

func (UnimplementedAuthHandler) AuthEnable(context.Context, *connect.Request[etcdserverpb.AuthEnableRequest]) (*connect.Response[etcdserverpb.AuthEnableResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("etcdserverpb.Auth.AuthEnable is not implemented"))
}

func (UnimplementedAuthHandler) AuthDisable(context.Context, *connect.Request[etcdserverpb.AuthDisableRequest]) (*connect.Response[etcdserverpb.AuthDisableResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("etcdserverpb.Auth.AuthDisable is not implemented"))
}

func (UnimplementedAuthHandler) AuthStatus(context.Context, *connect.Request[etcdserverpb.AuthStatusRequest]) (*connect.Response[etcdserverpb.AuthStatusResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("etcdserverpb.Auth.AuthStatus is not implemented"))
}

func (UnimplementedAuthHandler) Authenticate(context.Context, *connect.Request[etcdserverpb.AuthenticateRequest]) (*connect.Response[etcdserverpb.AuthenticateResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("etcdserverpb.Auth.Authenticate is not implemented"))
}

func (UnimplementedAuthHandler) UserAdd(context.Context, *connect.Request[etcdserverpb.AuthUserAddRequest]) (*connect.Response[etcdserverpb.AuthUserAddResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("etcdserverpb.Auth.UserAdd is not implemented"))
}

func (UnimplementedAuthHandler) UserGet(context.Context, *connect.Request[etcdserverpb.AuthUserGetRequest]) (*connect.Response[etcdserverpb.AuthUserGetResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("etcdserverpb.Auth.UserGet is not implemented"))
}

func (UnimplementedAuthHandler) UserList(context.Context, *connect.Request[etcdserverpb.AuthUserListRequest]) (*connect.Response[etcdserverpb.AuthUserListResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("etcdserverpb.Auth.UserList is not implemented"))
}

func (UnimplementedAuthHandler) UserDelete(context.Context, *connect.Request[etcdserverpb.AuthUserDeleteRequest]) (*connect.Response[etcdserverpb.AuthUserDeleteResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("etcdserverpb.Auth.UserDelete is not implemented"))
}

func (UnimplementedAuthHandler) UserChangePassword(context.Context, *connect.Request[etcdserverpb.AuthUserChangePasswordRequest]) (*connect.Response[etcdserverpb.AuthUserChangePasswordResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("etcdserverpb.Auth.UserChangePassword is not implemented"))
}

func (UnimplementedAuthHandler) UserGrantRole(context.Context, *connect.Request[etcdserverpb.AuthUserGrantRoleRequest]) (*connect.Response[etcdserverpb.AuthUserGrantRoleResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("etcdserverpb.Auth.UserGrantRole is not implemented"))
}

func (UnimplementedAuthHandler) UserRevokeRole(context.Context, *connect.Request[etcdserverpb.AuthUserRevokeRoleRequest]) (*connect.Response[etcdserverpb.AuthUserRevokeRoleResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("etcdserverpb.Auth.UserRevokeRole is not implemented"))
}

func (UnimplementedAuthHandler) RoleAdd(context.Context, *connect.Request[etcdserverpb.AuthRoleAddRequest]) (*connect.Response[etcdserverpb.AuthRoleAddResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("etcdserverpb.Auth.RoleAdd is not implemented"))
}

func (UnimplementedAuthHandler) RoleGet(context.Context, *connect.Request[etcdserverpb.AuthRoleGetRequest]) (*connect.Response[etcdserverpb.AuthRoleGetResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("etcdserverpb.Auth.RoleGet is not implemented"))
}

func (UnimplementedAuthHandler) RoleList(context.Context, *connect.Request[etcdserverpb.AuthRoleListRequest]) (*connect.Response[etcdserverpb.AuthRoleListResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("etcdserverpb.Auth.RoleList is not implemented"))
}

func (UnimplementedAuthHandler) RoleDelete(context.Context, *connect.Request[etcdserverpb.AuthRoleDeleteRequest]) (*connect.Response[etcdserverpb.AuthRoleDeleteResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("etcdserverpb.Auth.RoleDelete is not implemented"))
}

func (UnimplementedAuthHandler) RoleGrantPermission(context.Context, *connect.Request[etcdserverpb.AuthRoleGrantPermissionRequest]) (*connect.Response[etcdserverpb.AuthRoleGrantPermissionResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("etcdserverpb.Auth.RoleGrantPermission is not implemented"))
}

func (UnimplementedAuthHandler) RoleRevokePermission(context.Context, *connect.Request[etcdserverpb.AuthRoleRevokePermissionRequest]) (*connect.Response[etcdserverpb.AuthRoleRevokePermissionResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("etcdserverpb.Auth.RoleRevokePermission is not implemented"))
}
